# 4-Construct\prove-measures.R

# Goals of this script are:
#   - Take the measures generated by 4-Construct/construct-measures.R
#   - And/or the data generated by pivot-and-merge.R
#   - Produce evidence they are useful
#   - 

###################
# 1. Housekeeping #
###################

# Load functions
source(file="3-Unpack/parse-files-functions.R")
source(file="4-Construct/construct-measures-functions.R")

# Load classifications
source(file="3-Unpack/load-classifications.R")

############################################
# 2. Gather parameters about the job ahead #
############################################

# Obtain list of regions for which consolidated data is available
# regions_list <- generate_regions_list(data_parsed_directory)
# regions_list <- as.list("Adygeja_Resp")
regions_list <- as.list("Moskva")
regions_number <- length(regions_list)

# Define where outputs (eg graphs) should go
data_output_directory <- set_data_subdirectory(data_directory, data_download_date, "output")

##############################################
# 3. Load data, reshape it for graphs #
##############################################



##############################################
# 4. Create graphs #
##############################################
    

  ## HISTOGRAMS OF NOTIFICATION PRICES
  # Output three histograms for this region: listed price of notifications; same but only bottom three quartiles to show discontinuity at 500k; logged values across all dist
  notifications_maxPrice <- notifications_contracts_products_ungrouped %>%
                            filter(!TenderProcedureGroup %in% c("Olympic construction", "Preliminary selection") & !is.na(TenderProcedureGroup)) %>%
                            transmute(NotificationMaxPrice = NotificationLotCustomerRequirementMaxPrice,
                                      ProcedureGroup = TenderProcedureGroup)

  notifications_maxPrice_three_quartiles <- notifications_maxPrice %>%
    # filter(NotificationMaxPrice <= as.numeric(summary(notifications_maxPrice$NotificationMaxPrice)[5]))
    filter(NotificationMaxPrice <= as.numeric(quantile(notifications_maxPrice$NotificationMaxPrice, .81, na.rm = T)))

  # All notifications
  graph_title <- paste0("Distribution of initial listing prices for tenders in ", current_region_english, " (all quartiles)\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_notification_maxPrice_histogram_raw_all_quartiles.pdf")
  notification_maxPrice_histogram_raw_all_quartiles <- ggplot(notifications_contracts_products_ungrouped, aes(x=NotificationLotCustomerRequirementMaxPrice)) +
                                                        geom_histogram(bins = 200) +
                                                        labs(title = graph_title, x = "\nInitial listing price (rubles)") +
                                                        scale_x_continuous(labels = comma) +
                                                        theme_bw() +
                                                        annotate("text", 
                                                                 x = 0.95*(max(notifications_contracts_products_ungrouped$NotificationLotCustomerRequirementMaxPrice, na.rm = T)), y = 0, label = "\nA few very large\ntenders in each\nregion skew the\ndistribution right", vjust = 0, hjust = 1)
  print(notification_maxPrice_histogram_raw_all_quartiles)
  ggsave(plot = notification_maxPrice_histogram_raw_all_quartiles, filename = graph_file_name, device = "pdf")
  
  # Bottom three quarters of notifications
  graph_title <- paste0("Distribution of initial listing price in ", current_region_english, ", by procedure type (excl. fourth quartile)\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_notification_maxPrice_histogram_raw_three_quartiles.pdf")
  notification_maxPrice_histogram_raw_three_quartiles <- ggplot(notifications_maxPrice_three_quartiles, aes(x=NotificationMaxPrice, fill = ProcedureGroup)) +
    geom_histogram(bins = 200, show.legend = F) +
  # notification_maxPrice_histogram_raw_three_quartiles <- ggplot(notifications_maxPrice_three_quartiles, aes(x=NotificationMaxPrice, fill = ProcedureGroup)) +
    # geom_density(alpha = 0.2) +
    labs(title = graph_title, x = "\nInitial listing price (rubles)") +
    scale_x_continuous(labels = comma) +
    # scale_y_continuous(labels = NULL) +
    theme_bw() +
    scale_fill_tableau() +
    facet_wrap(~ ProcedureGroup, scales = "free_y", ncol = 1)
    #annotate("text", x = 450000, y = Inf, label = "\nRules change for\ntenders > 500k", vjust = 1, hjust = 1)
  print(notification_maxPrice_histogram_raw_three_quartiles)
  ggsave(plot = notification_maxPrice_histogram_raw_three_quartiles, filename = graph_file_name, device = "pdf", width = 8, height = 10)
  
  # All notifications, logged
  graph_title <- paste0("Distribution of initial listing prices (log base 10) for tenders in ", current_region_english, " (all quartiles)\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_notification_maxPrice_histogram_log_all_quartiles.pdf")
  notification_maxPrice_histogram_log_all_quartiles <- ggplot(notifications_maxPrice, aes(x=NotificationMaxPrice)) +
    geom_histogram(bins = 200) +
    labs(title = graph_title, x = "\nInitial listing price (rubles, log base 10)") +
    scale_x_continuous(labels = comma, trans = "log10") +
    theme_bw() +
    annotate("text", x = 350000, y = Inf, label = "\nRules change for\ntenders > 500k", vjust = 1, hjust = 1)
  print(notification_maxPrice_histogram_log_all_quartiles)
  ggsave(plot = notification_maxPrice_histogram_log_all_quartiles, filename = graph_file_name, device = "pdf")
  
  
  # Quick graph of price change
  hist(notifications_contracts_products_ungrouped$PriceChangePercentageNoOutliers, breaks = 100)
  
  # Can also facet with greyed-out underlying data, perhaps for comparing two agencies
  # http://docs.ggplot2.org/current/facet_wrap.html
  
  
  ## STACKED BAR CHART OF PROCEDURE CHOICE BY AGENCY
  procedure_choice_by_agency <- notifications_contracts_products_ungrouped %>%
    group_by(ContractCustomerRegNum, TenderProcedureGroup) %>%
      summarize(NotificationsPerProcedure = n()) %>% ungroup() %>%
    filter(TenderProcedureGroup %in% c("Open electronic auction", "Open tender", "Request for quotes")) %>%
    spread(key = TenderProcedureGroup, value = NotificationsPerProcedure, fill = 0) %>%
    mutate(`Total notifications` = (`Open electronic auction` + `Open tender` + `Request for quotes`)) %>%
    filter(`Total notifications` > 2) %>%
    transmute(Agency = ContractCustomerRegNum,
              # `Other` = Other/`Total notifications`,
              `Open electronic auction` = `Open electronic auction`/`Total notifications`,
              `Open tender` = `Open tender`/`Total notifications`,
              `Request for quotes` = `Request for quotes`/`Total notifications`,
              DominantProcedure = ifelse(`Open electronic auction` == 1, "0 Open electronic auction", 
                                         ifelse(`Open tender` == 1, "1 Open tender", 
                                                ifelse(`Request for quotes` == 1, "2 Request for quotes", "3 None")))) %>%
  # slice(1:20) %>%
    arrange(DominantProcedure, -`Open electronic auction`, -`Open tender`, -`Request for quotes`) %>%
    # arrange(DominantProcedure, -`Request for quotes`, -`Open tender`, -`Open electronic auction`, -Other) %>%
    # arrange(-`Open tender`, -`Open electronic auction`, -`Request for quotes`, -Other) %>%
    # arrange(-`Open tender`, `Request for quotes`, -`Open electronic auction`, -Other) %>%
    mutate(SortByProportionHigher = row_number(),
           ProportionOfAllAgencies = SortByProportionHigher/length(unique(notifications_contracts_products_ungrouped$ContractCustomerRegNum))) %>%
    gather(key = `Procedure`, value = Proportion, -Agency, -SortByProportionHigher, -ProportionOfAllAgencies, -DominantProcedure) %>%
    filter(`Procedure` != "Other")
  
  procedure_choice_by_agency$`Procedure` <- factor(procedure_choice_by_agency$`Procedure`,
                                                                   levels = c("Open electronic auction", "Open tender",
                                                                              "Request for quotes", "Other"))
  
  # Some variables to help label axes
  maximum_agency_number <- max(procedure_choice_by_agency$SortByProportionHigher)
  all_lower_discretion_agency_number <- max(procedure_choice_by_agency[procedure_choice_by_agency$DominantProcedure == "0 Open electronic auction", "SortByProportionHigher"])
    all_lower_discretion_agency_label <- round(all_lower_discretion_agency_number/maximum_agency_number, digits = 2)
  all_medium_discretion_agency_number <- max(procedure_choice_by_agency[procedure_choice_by_agency$DominantProcedure == "1 Open tender", "SortByProportionHigher"])
    all_medium_discretion_agency_label <- round(all_medium_discretion_agency_number/maximum_agency_number, digits = 2)
  all_higher_discretion_agency_number <- max(procedure_choice_by_agency[procedure_choice_by_agency$DominantProcedure == "2 Request for quotes", "SortByProportionHigher"])
    all_higher_discretion_agency_label <- round(all_higher_discretion_agency_number/maximum_agency_number, digits = 2)
    
  graph_title <- paste0("Choice of procurement procedure by agencies in ", current_region_english, ",\n2011-2015 (agencies with at least three purchases)\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_procedure_choice.pdf")
  procedure_choice_by_agency_graph <- procedure_choice_by_agency %>%
    ggplot(aes(x = SortByProportionHigher, y = Proportion, fill = `Procedure`)) +
    # ggplot(aes(x = SortByProportionHigher, fill = `Proportion of\nprocedures`)) +
    geom_bar(stat = "identity", width = 1) +
    # geom_histogram(bins = 50) +
    coord_flip() +
    theme_few() +
    scale_fill_tableau() +
    labs(title = graph_title,
         x = "Proportion of individual agencies\n",
         y = "\nProportion of agency purchases") +
    # theme(axis.text.y=element_blank(), axis.ticks.y=element_blank()) +
    scale_x_continuous(breaks = c(0, all_medium_discretion_agency_number, all_higher_discretion_agency_number, maximum_agency_number, maximum_agency_number/2, 3*maximum_agency_number/4),
                       labels = c("0", all_medium_discretion_agency_label, all_higher_discretion_agency_label, "1", "0.5", "0.75")) +
    theme(legend.position="bottom") +
    theme(legend.title=element_blank())
  print(procedure_choice_by_agency_graph)
  ggsave(plot = procedure_choice_by_agency_graph, filename = graph_file_name, device = "pdf", limitsize = T)
  

    
  ## AUCTION EFFICIENCY BY AGENCY (grouped products)
  auction_efficiency_by_agency <- notifications_contracts_products_grouped %>%
    filter(ContractCurrencyCode == "RUB" & ContractPrice > 0 & NotificationLotCustomerRequirementMaxPrice > 0) %>%
    transmute(AgencyID = ContractCustomerRegNum,
              `Initial price` = NotificationLotCustomerRequirementMaxPrice,
              `Final price` = ContractPrice,
              `Auction efficiency` = PriceChangePercentageNoOutliers,
              `Class of product` = ContractProductCodeLevel1,
              `Procedure type` = TenderProcedureDiscretion) %>%
    filter(!is.na(`Auction efficiency`) & `Final price` >= 1000) %>%
    group_by(AgencyID) %>%
    # group_by(AgencyID, `Class of product`) %>%
    # group_by(AgencyID, `Class of product`, `Procedure type`) %>%
    summarize(`Median auction efficiency` = median(`Auction efficiency`),
              `Mean auction efficiency` = mean(`Auction efficiency`),
                `Total spent` = sum(`Final price`),
                `Total spent (square root)` = sqrt(`Total spent`),
                `Total spent (log)` = log10(`Total spent`),
                `Total spent (inverse)` = 1/(`Total spent`),
                `Number of purchases` = n()) %>%
    filter(`Total spent` >= 100000 & `Total spent` <= 100000000000 & `Number of purchases` > 100) %>% # Thresholds for agencies alone
    # filter(`Total spent` >= 100000 & `Total spent` <= 10000000000 & `Number of purchases` > 10)     # Thresholds for agency/product pairs
    # filter(`Total spent` >= 10000 & `Total spent` <= 1000000000 & `Number of purchases` > 2)      # Thresholds for agency/product/procedure pairs
    left_join(agency_metadata) %>% left_join(efficiency_vs_specificity)
    
  # http://zakupki.gov.ru/pgz/public/action/orders/info/common_info/show?notificationId=694772
  # Classic example of highly efficient auction: max price 1.5 million, lowest bidder 74.5k (of course, given range of bids, subject to "bad good" problem)

  plot(auction_efficiency_by_agency$`Total spent`, auction_efficiency_by_agency$`Median auction efficiency`)
    lines(lowess(auction_efficiency_by_agency$`Total spent`, auction_efficiency_by_agency$`Median auction efficiency`), col = "blue")
  plot(auction_efficiency_by_agency$`Total spent (square root)`, auction_efficiency_by_agency$`Median auction efficiency`)
    lines(lowess(auction_efficiency_by_agency$`Total spent (square root)`, auction_efficiency_by_agency$`Median auction efficiency`), col = "blue")
  plot(auction_efficiency_by_agency$`Total spent (log)`, auction_efficiency_by_agency$`Median auction efficiency`)
    lines(lowess(auction_efficiency_by_agency$`Total spent (log)`, auction_efficiency_by_agency$`Median auction efficiency`), col = "blue")
  # plot(auction_efficiency_by_agency$`Total spent (inverse)`, auction_efficiency_by_agency$`Median auction efficiency`)
  
  # Two graphs here: auction efficiency vs spend  
  graph_title <- paste0("Efficiency of median auction vs total spent\nby agencies in ", current_region_english, ", 2011-2015\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_auction_efficiency_vs_spend.pdf")
    auction_efficiency_vs_spend_graph <- auction_efficiency_by_agency %>%
      ggplot(aes(x = `Total spent (log)`, y = `Median auction efficiency`)) +
      geom_point(aes(size = `Number of purchases`), alpha = 1/2) +
      stat_smooth(se = F, col = "orange") +
      theme_few() +
      scale_fill_tableau() +
      labs(title = graph_title,
           x = "\nTotal spent by agency (log scale)\n",
           y = "Median auction efficiency\n") +
      theme(legend.position="bottom")
    print(auction_efficiency_vs_spend_graph)
    ggsave(plot = auction_efficiency_vs_spend_graph, filename = graph_file_name, device = "pdf", limitsize = T)
   
     
  # specificity vs spend
  graph_title <- paste0("Purchase specificity vs total spent\nby agencies in ", current_region_english, ", 2011-2015\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_purchase_specificity_vs_spend.pdf")
    purchase_specificity_vs_spend_graph <- auction_efficiency_by_agency %>%
      ggplot(aes(x = `Total spent (log)`, y = MeanAbsoluteDeviationFromAverageSpendPerProduct)) +
      geom_point(aes(size = `Number of purchases`), alpha = 1/2) +
      stat_smooth(se = F, col = "orange") +
      theme_few() +
      scale_fill_tableau() +
      labs(title = graph_title,
           x = "\nTotal spent by agency (log scale)\n",
           y = "Measure of purchase specificity\n") +
      theme(legend.position="bottom")
    print(purchase_specificity_vs_spend_graph)
    ggsave(plot = purchase_specificity_vs_spend_graph, filename = graph_file_name, device = "pdf", limitsize = T)
    
    
  # And auction efficiency vs procedure (or product, boxplots)
  auction_efficiency_by_procedure <- notifications_contracts_products_grouped %>%
    filter(ContractCurrencyCode == "RUB" & ContractPrice > 0 & NotificationLotCustomerRequirementMaxPrice > 0) %>%
    transmute(AgencyID = ContractCustomerRegNum,
              `Initial price` = NotificationLotCustomerRequirementMaxPrice,
              `Final price` = ContractPrice,
              `Auction efficiency` = PriceChangePercentageNoOutliers,
              `ProductCode` = ContractProductCodeLevel1,
              `Procedure type` = TenderProcedureGroup) %>%
    filter(!is.na(`Auction efficiency`) & `Final price` >= 1000) #%>%
    # group_by(`Procedure type`) %>%
    # summarize(`Median auction efficiency` = median(`Auction efficiency`),
    #           `Mean auction efficiency` = mean(`Auction efficiency`),
    #           `Total spent` = sum(`Final price`),
    #           `Total spent (square root)` = sqrt(`Total spent`),
    #           `Total spent (log)` = log10(`Total spent`),
    #           `Total spent (inverse)` = 1/(`Total spent`),
    #           `Number of purchases` = n()) #%>%
    # filter(`Total spent` >= 100000 & `Total spent` <= 100000000000 & `Number of purchases` > 100) %>% # Thresholds for agencies alone
    # filter(`Total spent` >= 100000 & `Total spent` <= 10000000000 & `Number of purchases` > 10) %>%  # Thresholds for agency/product pairs
    # filter(`Total spent` >= 10000 & `Total spent` <= 1000000000 & `Number of purchases` > 2)      # Thresholds for agency/product/procedure pairs
    # left_join(okdp_product_classification, by = c("ProductCode"))
  
  graph_title <- paste0("Auction efficiency by procedure,\nfor agencies in ", current_region_english, ", 2011-2015\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_auction_efficiency_by_procedure.png")
  auction_efficiency_by_procedure_graph <- auction_efficiency_by_procedure %>%
                                            filter(`Procedure type` != "Olympic construction") %>%
                                            ggplot(aes(`Procedure type`, `Auction efficiency`)) +
                                            geom_boxplot() +
                                            geom_jitter(width = 0.5) +
                                            # coord_flip() +
                                            theme_few() +
                                            scale_fill_tableau() +
                                            labs(title = graph_title,
                                                 x = "",
                                                 y = "\nAuction efficiency")
  # print(auction_efficiency_by_procedure_graph)
  ggsave(plot = auction_efficiency_by_procedure_graph, filename = graph_file_name, device = "png", limitsize = T)
  
  # ggplot(auction_efficiency_by_product, aes(ProductName, `Median auction efficiency`)) + geom_point() + coord_flip()
  # Transport services have greatest padding
  
   
  ## RED FLAGS
  
  # Increase in contract price
  price_increases_by_agency <- notifications_contracts_products_ungrouped %>%
    filter(!is.na(PriceChange)) %>%
    rename(AgencyID = ContractCustomerRegNum) %>%
    mutate(PriceChangeDescription = ifelse(PriceChange < 0, "Decrease",
                                           ifelse(PriceChange == 0, "No change",
                                                  ifelse(PriceChange > 0, "Increase", NA)))) %>%
    count(AgencyID, PriceChangeDescription) %>%
    mutate(`Proportion of purchases` = prop.table(n)) %>%
    ungroup() %>%
    select(-n) %>%
    spread(key = PriceChangeDescription, value = `Proportion of purchases`, fill = 0) %>%
    mutate(`No decrease` = `No change` + Increase)

  # Check distribution of irregularities
  hist(log10(price_increases_by_agency$`No decrease`), breaks = 100)
  hist(log10(price_increases_by_agency$`No change`), breaks = 100)
  
  efficiency_vs_specificity_vs_increases <- efficiency_vs_specificity %>%
    inner_join(price_increases_by_agency) %>%
    rename(NoChange = `No change`) %>%
    mutate(MeanAuctionEfficiency = `Mean auction efficiency`,
           MedianAuctionEfficiency = `Median auction efficiency`,
           PurchaseSpecificity = MeanAbsoluteDeviationFromAverageSpendPerProduct/max(MeanAbsoluteDeviationFromAverageSpendPerProduct),
           CorruptionOpportunities = 1-(MedianAuctionEfficiency/min(MedianAuctionEfficiency))) %>%
    filter(`Number of purchases` > 9)
    
  # Try a model predicting increases/no change as function of IVs already specified
  price_increases_model_1 <- lm(`No decrease` ~ PurchaseSpecificity, data = efficiency_vs_specificity_vs_increases)  
  summary(price_increases_model_1)
  # The more specific purchases, lower percentage of no-change auctions, consistent with theory
  plot(efficiency_vs_specificity_vs_increases$PurchaseSpecificity, efficiency_vs_specificity_vs_increases$`No decrease`)
    lines(lowess(efficiency_vs_specificity_vs_increases$PurchaseSpecificity, efficiency_vs_specificity_vs_increases$`No decrease`), col = "blue")
  plot(efficiency_vs_specificity_vs_increases$CorruptionOpportunities, efficiency_vs_specificity_vs_increases$`No decrease`)
    lines(lowess(efficiency_vs_specificity_vs_increases$CorruptionOpportunities, efficiency_vs_specificity_vs_increases$`No decrease`), col = "blue")
  # Shows can't have this irregularity without larger opportunities
  # Graph this properly
  graph_title <- paste0("Proportion of purchases with no price decrease vs corruption opportunities,\nby agencies in ", current_region_english, ", 2011-2015\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_no_price_decrease_vs_opportunities.pdf")
  no_price_decrease_graph <- efficiency_vs_specificity_vs_increases %>%
    ggplot(aes(x = CorruptionOpportunities, y = `No decrease`)) +
    geom_point(aes(size = `Number of purchases`), alpha = 1/2) +
    # stat_smooth(se = F, col = "orange") +
    theme_few() +
    scale_fill_tableau() +
    labs(title = graph_title,
         x = "\nCorruption opportunities (measured by auction efficiency)\n",
         y = "Red flag: proportion of purchases with no price decrease\n") +
    theme(legend.position="bottom")
  print(no_price_decrease_graph)
    ggsave(plot = no_price_decrease_graph, filename = graph_file_name, device = "pdf", limitsize = T, width = 8, height = 8)
      
  price_increases_model_2 <- lm(`No decrease` ~ PurchaseSpecificity + CorruptionOpportunities, data = efficiency_vs_specificity_vs_increases)  
  summary(price_increases_model_2)
  # Effect holds, but CorruptionOpportunities and NoChange obviously quite highly correlated

  price_increases_model_3 <- lm(`No decrease` ~ PurchaseSpecificity + TotalSpent, data = efficiency_vs_specificity_vs_increases)  
  summary(price_increases_model_3)
  # Negative effect of specificity on no-change auctions holds, more spending associated with more no-change auctions

  price_increases_model_4 <- lm(`No decrease` ~ PurchaseSpecificity + CorruptionOpportunities + (PurchaseSpecificity * CorruptionOpportunities) + `Total spent (log)`, data = efficiency_vs_specificity_vs_increases)  
  summary(price_increases_model_4)
  # Unconditional negative effect of specificity holds, weaker. 
  interplot(price_increases_model_4, var1 = "PurchaseSpecificity", var2 = "CorruptionOpportunities", hist = T)
  # Greater the corruption opportunities, less (negative) effect of specificity
  # In lower-opportunity context, ie when padding at minimum, buying more specific goods strongly *decreases* irregularities,
  # which is completely consistent with a capacity story for those agencies (they're just not padding in first place)
  # As we move to higher-opportunity context, this "expertise" effect deadens to point where, for the mass of agencies
  # that are churning out tons of purchases with low auction efficiency, increasing specificity doesn't affect irregularities
  interplot(price_increases_model_4, var1 = "CorruptionOpportunities", var2 = "PurchaseSpecificity", hist = T)
  # Greater the specificity, stronger is effect of opportunities on red flag
  # For agency buying generic basket, increasing opportunities also increases irregularities
  # as basket becomes more specific, effect of increased padding becomes stronger
      

  ## SINGLE-SUPPLIER Contracts not notified (ie use of single-supplier)
  single_supplier_by_agency <- notifications_contracts_products_ungrouped %>%
    filter(ContractPrice >= 100000) %>% # Not a violation below 100k
    rename(AgencyID = ContractCustomerRegNum) %>%
    count(AgencyID, Match) %>%
    mutate(`Proportion of purchases` = prop.table(n)) %>%
    ungroup() %>%
    select(-n) %>%
    spread(key = Match, value = `Proportion of purchases`, fill = 0)
  
 single_supplier_by_agency_value <- notifications_contracts_products_ungrouped %>%
    filter(ContractPrice >= 100000) %>% # Not a violation below 100k
    rename(AgencyID = ContractCustomerRegNum) %>%
    group_by(AgencyID, Match) %>%
    summarize(ValueOfPurchases = sum(ContractPrice)) %>%
    mutate(`Proportion of value` = prop.table(ValueOfPurchases)) %>%
    ungroup() %>%
    select(-ValueOfPurchases) %>%
    spread(key = Match, value = `Proportion of value`, fill = 0)
   
  # Check distribution of irregularities
  hist(log10(single_supplier_by_agency$`Contract without notification`), breaks = 100)
  hist(log10(single_supplier_by_agency_value$`Contract without notification`), breaks = 100)
  
    
  efficiency_vs_specificity_vs_single_supplier <- efficiency_vs_specificity_vs_increases %>%
    inner_join(single_supplier_by_agency) %>%
    filter(`Number of purchases` > 9)
      
  single_supplier_model_1 <- lm(`Contract without notification` ~ PurchaseSpecificity, data = efficiency_vs_specificity_vs_single_supplier)
  summary(single_supplier_model_1)
  # No relationship, as expected with rare-ish event
  plot(efficiency_vs_specificity_vs_single_supplier$PurchaseSpecificity, efficiency_vs_specificity_vs_single_supplier$`Contract without notification`)
  plot(efficiency_vs_specificity_vs_single_supplier$CorruptionOpportunities, efficiency_vs_specificity_vs_single_supplier$`Contract without notification`)
    
  single_supplier_model_2 <- lm(`Contract without notification` ~ PurchaseSpecificity + CorruptionOpportunities + (PurchaseSpecificity * CorruptionOpportunities) + `Total spent (log)`, data = efficiency_vs_specificity_vs_single_supplier)  
  summary(single_supplier_model_2)
  interplot(single_supplier_model_2, var1 = "PurchaseSpecificity", var2 = "CorruptionOpportunities", hist = T)
  # Same as above but far weaker, as expected with a rarer red flag: when opps low, increasing spec reduces red flags
  interplot(single_supplier_model_2, var1 = "CorruptionOpportunities", var2 = "PurchaseSpecificity", hist = T)
  # Effects close to zero, strongest evidence consistent with above: when buying specific, increased opps increase red flags
  
  
  ## BUNCHED LISTING PRICES (discontinuities)
  purchases_bunched_at_thresholds <- notifications_contracts_products_ungrouped %>%
    filter(!is.na(NotificationLotCustomerRequirementMaxPrice)) %>%
    rename(AgencyID = ContractCustomerRegNum) %>%
    mutate(BunchedAtThreshold = ifelse(TenderProcedureGroup == "Request for quotes" & NotificationLotCustomerRequirementMaxPrice > (0.99 * 500000) & NotificationLotCustomerRequirementMaxPrice < (1.01 * 500000), "Bunched at request for quotes threshold",
                                       ifelse(TenderProcedureGroup == "Open electronic auction" & NotificationLotCustomerRequirementMaxPrice > (0.99 * 3000000) & NotificationLotCustomerRequirementMaxPrice < (1.01 * 3000000), "Bunched at open electronic auction threshold", "Not bunched"))) %>%
  # table(purchases_bunched_at_thresholds$BunchedAtThreshold)
  count(AgencyID, BunchedAtThreshold) %>%
    mutate(`Proportion of purchases` = prop.table(n)) %>%
    ungroup() %>%
  select(-n) %>%
  spread(key = BunchedAtThreshold, value = `Proportion of purchases`, fill = 0) %>%
  mutate(Bunched = 1-`Not bunched`)
  
  # Check distribution of irregularities
  hist((purchases_bunched_at_thresholds$Bunched), breaks = 100)
  
  efficiency_vs_specificity_vs_bunching <- efficiency_vs_specificity_vs_increases %>%
    inner_join(purchases_bunched_at_thresholds) 
  
  bunching_model_1 <- lm(Bunched ~ PurchaseSpecificity, data = efficiency_vs_specificity_vs_bunching)
  summary(bunching_model_1)
  # Weak relationship
  plot(efficiency_vs_specificity_vs_bunching$PurchaseSpecificity, efficiency_vs_specificity_vs_bunching$Bunched)
  plot(efficiency_vs_specificity_vs_bunching$CorruptionOpportunities, efficiency_vs_specificity_vs_bunching$Bunched)
  plot(efficiency_vs_specificity_vs_bunching$CorruptionOpportunities, efficiency_vs_specificity_vs_bunching$`Bunched at request for quotes threshold`)
  plot(efficiency_vs_specificity_vs_bunching$CorruptionOpportunities, efficiency_vs_specificity_vs_bunching$`Bunched at open electronic auction threshold`)
  
  # Graph the higher-level bunching
  graph_title <- paste0("Proportion of purchases near thresholds vs corruption opportunites,\nby agencies in ", current_region_english, ", 2011-2015\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_bunching_vs_opportunities.pdf")
  bunching_graph <- efficiency_vs_specificity_vs_bunching %>%
    ggplot(aes(x = CorruptionOpportunities, y = `Bunched at open electronic auction threshold`)) +
    geom_point(aes(size = `Number of purchases`), alpha = 1/2) +
    # stat_smooth(se = F, col = "orange") +
    theme_few() +
    scale_fill_tableau() +
    labs(title = graph_title,
         x = "\nCorruption opportunities (measured by auction efficiency)\n",
         y = "Red flag: proportion of purchases listed within 1% of threshold\n") +
    theme(legend.position="bottom")
  print(bunching_graph)
  ggsave(plot = bunching_graph, filename = graph_file_name, device = "pdf", limitsize = T, width = 8, height = 8)
    
  bunching_model_2 <- lm(Bunched ~ PurchaseSpecificity + CorruptionOpportunities + (PurchaseSpecificity * CorruptionOpportunities) + `Total spent (log)`, data = efficiency_vs_specificity_vs_bunching)  
  summary(bunching_model_2)
  interplot(bunching_model_2, var1 = "PurchaseSpecificity", var2 = "CorruptionOpportunities", hist = T)
  # When opps low, increasing spec means less likely to have bunching; effect weakens with greater opps
  # Greater opps means tons of money to go round?
  interplot(bunching_model_2, var1 = "CorruptionOpportunities", var2 = "PurchaseSpecificity", hist = T)
  # Weak evidence for anything
  
  
  ## REVISIONS
  revisions_by_agency <- notifications_contracts_products_grouped %>%
    filter(Match == "Notification matches contract") %>%
    transmute(AgencyID = ContractCustomerRegNum,
              NotificationRevised,
              ContractRevised,
              AnyRevision = ifelse((NotificationRevised == "Y" | ContractRevised == "Y"), 1, 0)) %>%
    group_by(AgencyID) %>%
    summarize(ProportionOfPurchasesModified = mean(AnyRevision))
  
  revisions_by_agency_count <- notifications_contracts_products_grouped %>%
    filter(Match == "Notification matches contract") %>%
    transmute(AgencyID = ContractCustomerRegNum,
              `Revisions to notification` = (NotificationVersionNumber - 1), # Version numbers start at 1
              `Revisions to contract` = ContractVersionNumber, # Version numbers start at 0
              `Total revisions` = `Revisions to notification` + `Revisions to contract`) %>%
    group_by(AgencyID) %>%
    summarize(`Median total revisions` = median(`Total revisions`),
              `Mean total revisions` = mean(`Total revisions`),
              `Mean contract revisions` = mean(`Revisions to contract`))
  
  # Check distribution of irregularities
  hist((revisions_by_agency$ProportionOfPurchasesModified), breaks = 100)
  hist(revisions_by_agency_count$`Mean contract revisions`, breaks = 100)
  hist(revisions_by_agency_count$`Mean total revisions`, breaks = 100)
  
  efficiency_vs_specificity_vs_revisions <- efficiency_vs_specificity_vs_increases %>%
    inner_join(revisions_by_agency) 
  
  revisions_model_1 <- lm(ProportionOfPurchasesModified ~ PurchaseSpecificity, data = efficiency_vs_specificity_vs_revisions)
  summary(revisions_model_1)
  # More specific purchasing, more modifications to contract (but consistent with capacity)
  
  revisions_model_2 <- lm(ProportionOfPurchasesModified ~ PurchaseSpecificity + CorruptionOpportunities + (PurchaseSpecificity * CorruptionOpportunities) + `Total spent (log)`, data = efficiency_vs_specificity_vs_revisions)  
  summary(revisions_model_2)
  interplot(revisions_model_2, var1 = "PurchaseSpecificity", var2 = "CorruptionOpportunities", hist = T)
  # When opps low, increasing spec means more likely to have modifications, weakens as opportunities increase
  interplot(revisions_model_2, var1 = "CorruptionOpportunities", var2 = "PurchaseSpecificity", hist = T)
  # When buying generic, effect of opportunities on modiciations is roughly nil
  # When buying specific, increasing opportunities correlated with fewer modifications
  
  
  ## DRAMATIC PRICE DECREASE >50%
  large_price_decrease_by_agency <- notifications_contracts_products_ungrouped %>%
    filter(!is.na(PriceChangePercentage) & TenderProcedureGroup == "Open electronic auction") %>%
    rename(AgencyID = ContractCustomerRegNum) %>%
    mutate(LargePriceDecrease = ifelse(PriceChangePercentage <= -50, "Large price decrease", "No large price decrease")) %>%
    # table(large_price_decrease_by_agency$LargePriceDecrease)
    count(AgencyID, LargePriceDecrease) %>%
    mutate(`Proportion of purchases` = prop.table(n)) %>%
    ungroup() %>%
    select(-n) %>%
    spread(key = LargePriceDecrease, value = `Proportion of purchases`, fill = 0)
  
  # Check distribution of irregularities
  hist((large_price_decrease_by_agency$`Large price decrease`), breaks = 100)
  
  efficiency_vs_specificity_vs_large_price_decrease <- efficiency_vs_specificity_vs_increases %>%
    inner_join(large_price_decrease_by_agency) 
  
  decreases_model_1 <- lm(`Large price decrease` ~ PurchaseSpecificity, data = efficiency_vs_specificity_vs_large_price_decrease)
  summary(revisions_model_1)
  # More specific purchasing, larger proportion of electronic auctions with price decrease > 50%
  
  # Graph the large price decreases
  graph_title <- paste0("Proportion of purchases with dramatic price decrease vs corruption opportunities,\nby agencies in ", current_region_english, ", 2011-2015\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_large_price_decreases_vs_opportunities.pdf")
  large_price_decrease_graph <- efficiency_vs_specificity_vs_large_price_decrease %>%
    ggplot(aes(x = CorruptionOpportunities, y = `Large price decrease`)) +
    geom_point(aes(size = `Number of purchases`), alpha = 1/2) +
    # stat_smooth(se = F, col = "orange") +
    theme_few() +
    scale_fill_tableau() +
    labs(title = graph_title,
         x = "\nCorruption opportunities (measured by auction efficiency)\n",
         y = "Red flag: proportion of purchases where price decreased >50% over auction\n") +
    theme(legend.position="bottom")
  print(large_price_decrease_graph)
  ggsave(plot = large_price_decrease_graph, filename = graph_file_name, device = "pdf", limitsize = T, width = 8, height = 8)
  
  decreases_model_2 <- lm(`Large price decrease` ~ PurchaseSpecificity + CorruptionOpportunities + (PurchaseSpecificity * CorruptionOpportunities) + `Total spent (log)`, data = efficiency_vs_specificity_vs_large_price_decrease)  
  summary(decreases_model_2)
  interplot(decreases_model_2, var1 = "PurchaseSpecificity", var2 = "CorruptionOpportunities", hist = T)
  # When opps low, increasing spec means less likely to experience large price decrease; effect deadens w/ larger opps
  # A kind of zero-sum scarcity story possible here: when opps plentiful, specificity matters less as plenty to go round?
  # When opps not so plentiful, specificity (expertise gap) has 
  interplot(decreases_model_2, var1 = "CorruptionOpportunities", var2 = "PurchaseSpecificity", hist = T)
  # When buying generic, greater opportunities lead to less corruption
  # When buying specific, increasing opportunities doesn't reduce corruption by nearly as much

  
  ## REPEAT WINNERS
  contracts_per_supplier_per_agency <- notifications_contracts_products_grouped %>%
    filter(!is.na(ContractSupplierParticipantINN)) %>%
    rename(AgencyID = ContractCustomerRegNum) %>%
    group_by(AgencyID, ContractSupplierParticipantINN) %>%
      count(AgencyID, ContractSupplierParticipantINN) %>% 
    mutate(`Proportion of purchases` = prop.table(n)) %>%
    group_by(AgencyID) %>%
      summarize(`Median percentage of contracts` = 100 * median(`Proportion of purchases`),
                `Mean percentage of contracts` = 100 * mean(`Proportion of purchases`))
  
  contract_value_per_supplier_per_agency <- notifications_contracts_products_grouped %>%
    filter(!is.na(ContractSupplierParticipantINN) & !is.na(ContractPrice)) %>%
    rename(AgencyID = ContractCustomerRegNum) %>%
    group_by(AgencyID, ContractSupplierParticipantINN) %>%
      summarize(ValueOfPurchases = sum(ContractPrice)) %>%
    mutate(`Proportion of value` = prop.table(ValueOfPurchases)) %>%
    group_by(AgencyID) %>%
    summarize(`Median value of contracts` = median(`Proportion of value`),
              `Mean value of contracts` = mean(`Proportion of value`))
  
  # Check distribution of irregularities
  hist(contracts_per_supplier_per_agency$`Median percentage of contracts`, breaks = 100) # This version gives pretty flat lines, which just means effect not conditional
  hist(contracts_per_supplier_per_agency$`Mean percentage of contracts`, breaks = 100) # 
  hist(contract_value_per_supplier_per_agency$`Median value of contracts`, breaks = 100) # This version gives
  
  efficiency_vs_specificity_vs_repeat_winners <- contract_value_per_supplier_per_agency %>%
    inner_join(efficiency_vs_specificity_vs_increases)
  
  repeat_winners_model_1 <- lm(`Median value of contracts` ~ PurchaseSpecificity, data = efficiency_vs_specificity_vs_repeat_winners)
  summary(repeat_winners_model_1)
  # Increased specificity associated with higher median proportion of agency contracts awarded to each supplier
  plot(efficiency_vs_specificity_vs_repeat_winners$PurchaseSpecificity, efficiency_vs_specificity_vs_repeat_winners$`Median value of contracts`)
  
  repeat_winners_model_2 <- lm(`Median value of contracts` ~ PurchaseSpecificity + CorruptionOpportunities + (PurchaseSpecificity * CorruptionOpportunities) + `Total spent (log)`, data = efficiency_vs_specificity_vs_repeat_winners)  
  summary(repeat_winners_model_2)
  interplot(repeat_winners_model_2, var1 = "PurchaseSpecificity", var2 = "CorruptionOpportunities", hist = T)
  # When opportunities are low, increasing specificity increases (slightly) red flag
  interplot(repeat_winners_model_2, var1 = "CorruptionOpportunities", var2 = "PurchaseSpecificity", hist = T)
  # When buying usual things, opportunties have no effect; when buying unusual basket, increasing opportunities decreases red flag
  
  # Herfindahl index probably more useful
  value_of_purchases_per_supplier_per_agency <- notifications_contracts_products_grouped %>%
    filter(!is.na(ContractSupplierParticipantINN) & !is.na(ContractPrice) & ContractPrice > 0) %>%
    rename(AgencyID = ContractCustomerRegNum) %>%
    group_by(AgencyID, ContractSupplierParticipantINN) %>%
      summarize(ValueOfPurchases = sum(ContractPrice)) %>%
    ungroup() %>%
    data.frame()
  
  HHI <- diversity(value_of_purchases_per_supplier_per_agency, type = "herfindahl-hirschman")
  herfindahl_index_suppliers_per_agency <- data.frame(AgencyID = as.character(row.names(HHI)), HHI = HHI[,1], stringsAsFactors = F)
  rm(HHI)
  hist(herfindahl_index_suppliers_per_agency$HHI, breaks = 20)
  
  efficiency_vs_specificity_vs_repeat_winners_hhi <- herfindahl_index_suppliers_per_agency %>%
    inner_join(efficiency_vs_specificity_vs_increases) %>%
    mutate(HHIinverselog = log10(HHI))
  hist(efficiency_vs_specificity_vs_repeat_winners_hhi$HHI, breaks = 40)
  hist(efficiency_vs_specificity_vs_repeat_winners_hhi$HHIinverselog, breaks = 40)
  
  repeat_winners_hhi_model_1 <- lm(HHI ~ PurchaseSpecificity, data = efficiency_vs_specificity_vs_repeat_winners_hhi)
  summary(repeat_winners_hhi_model_1)
  # Increased specificity associated with higher HHI concentration
  plot(efficiency_vs_specificity_vs_repeat_winners_hhi$PurchaseSpecificity, efficiency_vs_specificity_vs_repeat_winners_hhi$HHI)
  plot(efficiency_vs_specificity_vs_repeat_winners_hhi$CorruptionOpportunities, efficiency_vs_specificity_vs_repeat_winners_hhi$HHI)
  
  # Save the HHI vs specificity graph
  graph_title <- paste0("Concentration of spending on winning suppliers vs purchase specificity,\nby agencies in ", current_region_english, ", 2011-2015\n")
    graph_file_name <- paste0(data_output_directory_region, current_region, "_winner_concentration_vs_specificity.pdf")
  hhi_vs_specificity_graph <- efficiency_vs_specificity_vs_repeat_winners_hhi %>%
    ggplot(aes(x = PurchaseSpecificity, y = HHI)) +
    geom_point(aes(size = `Number of purchases`), alpha = 1/2) +
    stat_smooth(se = F, col = "orange") +
    theme_few() +
    scale_fill_tableau() +
    labs(title = graph_title,
         x = "\nMeasure of purchase specificity\n",
         y = "Red flag: winner concentration (Herfindahl-Hirschman Index)\n") +
    theme(legend.position="bottom")
  print(hhi_vs_specificity_graph)
  ggsave(plot = hhi_vs_specificity_graph, filename = graph_file_name, device = "pdf", limitsize = T, width = 8, height = 8)
  
  repeat_winners_hhi_model_2 <- lm(HHI ~ PurchaseSpecificity + CorruptionOpportunities + (PurchaseSpecificity * CorruptionOpportunities) + `Total spent (log)`, data = efficiency_vs_specificity_vs_repeat_winners_hhi)  
  summary(repeat_winners_hhi_model_2)
  interplot(repeat_winners_hhi_model_2, var1 = "PurchaseSpecificity", var2 = "CorruptionOpportunities", hist = T)
  # When opportunities are low, increasing specificity decreases (insignificantly)
  interplot(repeat_winners_hhi_model_2, var1 = "CorruptionOpportunities", var2 = "PurchaseSpecificity", hist = T)
  # When buying usual things, opportunties have negative effect; 
  
  # Can also do herfindahl on a product basis and then calculate deviations from that?
  
  
  ## LISTING DURATION
  listing_duration_by_agency <- notifications_contracts_products_grouped %>%
    filter(!is.na(ProcedureDuration) & ProcedureDuration > 0) %>%
    rename(AgencyID = ContractCustomerRegNum) %>%
    group_by(AgencyID) %>%
      summarize(`Median procedure duration` = median(ProcedureDuration))
  
  listing_duration_by_agency_threshold <- notifications_contracts_products_grouped %>%
    filter(!is.na(ProcedureDuration) & ProcedureDuration > 0) %>%
    rename(AgencyID = ContractCustomerRegNum) %>%
    mutate(ProcedureLength = ifelse(ProcedureDuration < 23, "Short procedure",
                                    ifelse(ProcedureDuration >= 23, "Normal procedure", NA))) %>%
    count(AgencyID, ProcedureLength) %>%
    mutate(`Proportion of purchases` = prop.table(n)) %>%
    ungroup() %>%
    select(-n) %>%
    spread(key = ProcedureLength, value = `Proportion of purchases`, fill = 0)
  
  # Check distribution of irregularities
  hist(listing_duration_by_agency$`Median procedure duration`, breaks = 100)
  hist(listing_duration_by_agency_threshold$`Short procedure`, breaks = 100) # Using this version doesn't clear anything up

  efficiency_vs_specificity_vs_duration <- efficiency_vs_specificity_vs_increases %>%
    inner_join(listing_duration_by_agency) 
  
  plot(efficiency_vs_specificity_vs_duration$CorruptionOpportunities, efficiency_vs_specificity_vs_duration$`Median procedure duration`)
    
  listing_duration_model_1 <- lm(`Median procedure duration` ~ PurchaseSpecificity, data = efficiency_vs_specificity_vs_duration)
  summary(listing_duration_model_1)
  # More specific purchasing, longer median duration
  
  listing_duration_model_2 <- lm(`Median procedure duration` ~ PurchaseSpecificity + CorruptionOpportunities + (PurchaseSpecificity * CorruptionOpportunities) + `Total spent (log)`, data = efficiency_vs_specificity_vs_duration)  
  summary(listing_duration_model_2)
  interplot(listing_duration_model_2, var1 = "PurchaseSpecificity", var2 = "CorruptionOpportunities", hist = T)
  # When opportunities are low, increasing specificity increases (slightly) red flag
  interplot(listing_duration_model_2, var1 = "CorruptionOpportunities", var2 = "PurchaseSpecificity", hist = T)
  # When buying usual things, opportunties have no effect; when buying unusual basket, increasing opportunities decreases red flag
  
  
  ## MERGE EVERY MEASURES TOGETHER
  all_red_flags <- efficiency_vs_specificity_vs_increases %>%
    inner_join(efficiency_vs_specificity_vs_single_supplier) %>%
    inner_join(efficiency_vs_specificity_vs_bunching) %>%
    inner_join(efficiency_vs_specificity_vs_large_price_decrease) %>%
    inner_join(efficiency_vs_specificity_vs_repeat_winners_hhi) %>%
    select(`No decrease`, `Contract without notification`, Bunched, `Large price decrease`, HHI)
  
  cor(all_red_flags)
  # The large negative correlations are where we expect it by construction: eg "no decrease" vs "large decrease"
  
  # Quick PCA based on http://rstatistics.net/principal-component-analysis/
  all_red_flags_scaled <- data.frame(scale(all_red_flags))
  all_red_flags_pca <- prcomp(all_red_flags_scaled)
  summary(all_red_flags_pca)
  screeplot(all_red_flags_pca, type = "lines")
  variances <- all_red_flags_pca$sdev^2
  library(qcc)
  pareto.chart(variances, ylab = "Variances")
  
  # PCA based on http://www.statmethods.net/advstats/factor.html
  fit <- princomp(all_red_flags_scaled, cor = T)
  summary(fit) # print variance accounted for 
  loadings(fit) # pc loadings 
  plot(fit,type="lines") # scree plot 
  fit$scores # the principal components
  biplot(fit) # Shows that no/large decrease work against each other (as expected), while single supplier & HHI orthogonal
  
  
  efficiency_vs_spend <- lm(`Median auction efficiency` ~ `Total spent`, data = auction_efficiency_by_agency)
  summary(efficiency_vs_spend)
  # No matter which rules you apply to exclude extreme values, grouping by agency/product/procedure, 
  # relationship is positive and significant: spending more associated with lower auction efficiency
  # 1,000,000,000 increase in spending associated with 1.5-2.0 percentage point decrease in efficiency under different groupings
  # But clearly spending less not sufficient for higher efficiency, triangular pattern
  
  
  # % CALCULATE AVERAGE GAP BY HIGH-LEVEL PRODUCT CODE, THEN AGENCY DEVIATIONS
  # % DOES VARIANCE OF THE GAP TELL US ANYTHING?
  # % MODEL THE GAP AS FUNCTION OF SOME THINGS, LOOK AT RESIDUALS?
  # % Can go within agency, see proportion of purchases where padding+restriction
  # 
  
  
# } # Closes control loop over regions_list

# ENDS