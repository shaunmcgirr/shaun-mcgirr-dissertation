# 5-Test\explore-data.R

# Goals of this script are:
#   - Take the measures generated by 4-Construct/construct-measures.R
#   - Explore this with an eye to appropriate model selection for empirical test
#   - 

###################
# 1. Housekeeping #
###################

# Load functions
source(file="3-Unpack/parse-files-functions.R")
source(file="4-Construct/construct-measures-functions.R")

# Load classifications
source(file="3-Unpack/load-classifications.R")

############################################
# 2. Gather parameters about the job ahead #
############################################

# Obtain list of regions for which consolidated data is available
# regions_list <- generate_regions_list(data_parsed_directory)
regions_list <- as.list("Adygeja_Resp")
# regions_list <- as.list("Moskva")
regions_number <- length(regions_list)

# Define where outputs (eg graphs) should go
data_output_directory <- set_data_subdirectory(data_directory, data_download_date, "output")

##############################################
# 3. Load data, explore freely #
##############################################

# Loop over regions, processing them in turn
for(r in 1:regions_number){
  # r <- 1
  current_region <- as.character(regions_list[r])
  current_region_english <- generate_english_region_name(current_region)
  data_output_directory_region <- paste0(data_output_directory, current_region, "/")
  
    # Load the file of measures
    file_to_process <- paste0(data_output_directory, current_region, "/",
                              current_region, "_notification_contract_matches_",
                              data_download_date, ".rda")
    load(file=file_to_process)
  
  ## REMOVE matches of low quality
  # Function to count na in columns of data frame
  na_count <- function(x) sapply(x, function(y) sum(is.na(y)))
  # na_count(notification_contract_matches)


  ## CALCULATE PER-AGENCY MEASURES AND EXPLORE
  discretion_by_agency_largest_agencies <- notification_contract_matches %>%
                            group_by(NotificationOrderPlacerFullName) %>%
                              mutate(NumberOfTenders = n(), NumberOfUniqueProducts = n_distinct(NotificationLotProductCode),
                                     MeanPriceChangePercentage = mean(PriceChangePercentageNoOutliers, na.rm = T),
                                     TotalSpent = sum(NotificationLotCustomerRequirementMaxPrice, na.rm = T)) %>% ungroup() %>%
                            group_by(NotificationOrderPlacerFullName, NumberOfTenders, NumberOfUniqueProducts, MeanPriceChangePercentage, TotalSpent, TenderProcedureDiscretion) %>%
                              tally() %>%
                              spread(key = TenderProcedureDiscretion, value = n, fill = 0) %>% ungroup() %>%
                            mutate(ProportionLowerDiscretion = `Lower discretion`/NumberOfTenders,
                                   ProportionMediumDiscretion = `Medium discretion`/NumberOfTenders,
                                   ProportionHigherDiscretion = `Higher discretion`/NumberOfTenders) %>%
                            filter(NumberOfTenders >= 100)
  
  hist(discretion_by_agency_largest_agencies$ProportionHigherDiscretion)
  hist(discretion_by_agency_largest_agencies$MeanPriceChangePercentage)
  
  # Number of tenders obviously correlated with number of unique products
  plot((discretion_by_agency_largest_agencies$NumberOfTenders), (discretion_by_agency_largest_agencies$NumberOfUniqueProducts))
  plot(log(discretion_by_agency_largest_agencies$NumberOfTenders), log(discretion_by_agency_largest_agencies$NumberOfUniqueProducts))
  
  # Do these as stacked bar chart
  plot((discretion_by_agency_largest_agencies$NumberOfUniqueProducts), discretion_by_agency_largest_agencies$ProportionLowerDiscretion)
  # If you buy lots of different products, choose lower discretion (auctions) more often (failure to coordinate? or lack of knowledge?)
  plot((discretion_by_agency_largest_agencies$NumberOfUniqueProducts), discretion_by_agency_largest_agencies$ProportionMediumDiscretion)
  # Most agencies choose few medium discretion (tenders), those choosing more often buy similar products
  plot((discretion_by_agency_largest_agencies$NumberOfUniqueProducts), discretion_by_agency_largest_agencies$ProportionHigherDiscretion)
  # Agencies buying similar products vary in choices of higher discretion, those buying unique don't choose it often
  # Consistent with my model? Unique products -> informational advantage, failure to cooperate on higher discretion procedure
  # Agencies buying unique products swing either high or low discretion, not medium
  
  plot(log(discretion_by_agency_largest_agencies$NumberOfUniqueProducts), discretion_by_agency_largest_agencies$MeanPriceChangePercentage)
  # Few types of products (lower expertise), well-functioning procurement should mean higher auction efficiency, price change large in magnitude (more negative)
  # According to my theory, this is exactly where corruption is easiest to maintain (and evident in Adygeja)
  # Cutting against this is obvious fact that buying more unique products makes it harder to know the market (this dominates in Moscow)
  # Logic: few products makes it easier to get good prices (if you're clean) and easier to build in fat (if you're corrupt);
  #        if you buy lots of products, not going to get good prices even if you are clean, 
  
  plot(discretion_by_agency_largest_agencies$ProportionHigherDiscretion, discretion_by_agency_largest_agencies$MeanPriceChangePercentage)
  # No real relationship here
  
  
  ## QUICK MODELS
  
  quick_model_1 <- lm(ProportionHigherDiscretion ~ NumberOfUniqueProducts, data = discretion_by_agency_largest_agencies)                          
  summary(quick_model_1)
  # More unique products -> informational advantage -> failure to coordinate on higher discretion procedure
  # More unique products -> less knowledge of market for each one -> capacity leads to trust in market? (if didn't know, would prob choose discretion)
  
  quick_model_2 <- lm(MeanPriceChangePercentage ~ NumberOfUniqueProducts, data = discretion_by_agency_largest_agencies)                          
  summary(quick_model_2)
  # More unique products -> worse auction efficiency (more potential for corruption), contradicts above slightly
  
  quick_model_3 <- lm(MeanPriceChangePercentage ~ NumberOfUniqueProducts + ProportionHigherDiscretion, data = discretion_by_agency_largest_agencies)                          
  summary(quick_model_3)
  # Controlling for likelihood of choosing higher discretion (should really analyze the three subsets), more unique products associated with less auction efficiency
  # Underscores need for "smoking gun" measures based on irregularities
  
  # Mixed-effects/hierarchical models from http://tutorials.iq.harvard.edu/R/Rstatistics/Rstatistics.html
  quick_model_4 <- lmer(PriceChangePercentageNoOutliers ~ 1 + (1|NotificationOrderPlacerFullName), data = notification_contract_matches, REML = F)
  summary(quick_model_4)
  # ~10.6% variance explained by Agency
  
  quick_model_5 <- lmer(PriceChangePercentageNoOutliers ~ 1 + (1|TenderProcedureDiscretion), data = notification_contract_matches, REML = F)
  summary(quick_model_5)
  # 0.9% explained by TenderProcedureDiscretion

  quick_model_6 <- lmer(PriceChangePercentageNoOutliers ~ 1 + (1|NotificationLotProductCodeLevel1), data = notification_contract_matches, REML = F)
  summary(quick_model_6)
  # 6.8% explained by NotificationLotProductCodeLevel1
  
  # Reactions:
  # The more expertise (unique products) less likely to use discretionary procedures
  

  
  
###############
# 4. MODELS #
###############
    
  # Fully specified models at TENDER level
  # Discretionary procedure choice = -expertise +capacity
  # Discretionary procedure choice = ()|tender + ()|agency
  
  # Use this to run/save multiple models at once
  # http://www.quantide.com/website/dplyr-do-tips-using-programming/
    
} # Closes control loop over regions_list
                    

# ENDS